# 1.
> Why is it safe to eagerly define the variable bound to a function’s name when other variables must wait until after they are initialized before they can be used?

The self-reference for variables across declaration/initialization is undesirable/not useful. For functions it is (recursion).

Edit: Ah, I see. It's about *safety*, yes. For functions, a recursive call inside the def and a real call outside the def are two different things,
and the latter is the one we must ensure happens only after definition (which it always will). Because that is a real *usage*, whereas the former is a placeholder/recipe for what to do if/when the function is actually used. Or something like that. It's still a little confusing for me.

# 2.
> How do other languages you know handle local variables that refer to the same name in their initializer, like:
> ```
> var a = "outer";
> {
>   var a = a;
> }
> ```
> Is it a runtime error? Compile error? Allowed? Do they treat global variables differently? Do you agree with their choices? Justify your answer.

C and C++ (by inheritence) both put the variable in scope, with undefined value, immediately after the declaration and before initialization! So `var a = a;` is equivalent to `var a; a = a;`. Pretty interesting. Maybe just an oversight, or adherence to a very lightweight approach.

Java does it sensibly, see solution.

# 3.
> Extend the resolver to report an error if a local variable is never used.

I looked at the solution. Pretty neat. Straightforward though. So satisfying that the fruit of our labor there is that nice bit of code at the end of `endScope()` that reports errors for all unused variables. Clean.

# 4.
> Our resolver calculates which environment the variable is found in, but it’s still looked up by name in that map. A more efficient environment representation would store local variables in an array and look them up by index.
>
> Extend the resolver to associate a unique index for each local variable declared in a scope. When resolving a variable access, look up both the scope the variable is in and its index and store that. In the interpreter, use that to quickly access a variable by its index instead of using a map.

This was fun! This chapter was conceptually hard for me, and sure enough, a few hours of plugging away at this left me with a far better understanding.

My solution turned out to be quite similar to Bob's. But as usual I cleaned mine up and took most of his good ideas after checking the solution.

Changes:
- have the resolver export "slot" for each variable access, in addition to distance. I had a conceptual hitch here: I didn't distinguish Resolver.Variable which is for declarations, and what we export to the Interpreter, which corresponds to *accesses*. This is a major gap in understanding, haha. But I got it down pat afterwards :)
- simple interpreter changes to use this new ResolvedVarInfo
- environment: change the map to an array. this one was also conceptually hard. it seemed flimsy. and how in LoxCallable.call() you just `environment.define(value)` (an append on the underlying array) on each of the params. but yes, this works! the resolver and environment/interpreter walk the AST and create scopes and declarations THE SAME (incl. same order), so it all lines up. i was also skeptical due to the basic fact that one is runtime and the other is compile-time, but that's a superficial difference here. this is what static analysis is. some things (e.g. lexical-scope) are knowable about how a program will run before you run it! see notes.md ch11 bullet 2 for a good quote explaining my functions hangup.
- globals: make this a map in the interpreter (copied bob). works quite well. I wanted to resolve globals, too, but it was a little awkward with the "clock" builtin (this caused an OBO bug with the slots that the llm helped me find quickly, luckily).

note on "slot" vs "idx":
i started with idx for ResolvedVarInfo, but I noticed bob uses slot. slot "suggests a reserved place that can hold a value" (GPT5). i agree it's more specific, and am starting to understand the nuance i suppose. apparently it's also convention for compilers.