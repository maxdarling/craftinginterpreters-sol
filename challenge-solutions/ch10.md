# 1.
> Our interpreter carefully checks that the number of arguments passed to a function matches the number of parameters it expects. Since this check is done at runtime on every call, it has a performance cost. Smalltalk implementations don’t have that problem. Why not?


Essentially because the smalltalk func decl/invo syntax has the func name and params/args interleaved and separated by colons.

So for the following...
```smalltalk
# declaration
Point>>moveByX: dx andY: dy
   x := x + dx.
   y := y + dy.

# call
point moveByX: 5 andY: 10
```

...the full method name is `moveByX:andY:`. The param/arg count matches the colon count, and you can check this at parse time.
You could also achieve this in a lang if e.g. all funcs/method identifiers must end with their arity. E.g. `moveByXAndY2(5, 10)`. But this feels clunky of course.

# 2.
> Lox’s function declaration syntax performs two independent operations. It creates a function and also binds it to a name. This improves usability for the common case where you do want to associate a name with the function. But in functional-styled code, you often want to create a function to immediately pass it to some other function or return it. In that case, it doesn’t need a name.
>
>
> Languages that encourage a functional style usually support anonymous functions or lambdas—an expression syntax that creates a function without binding it to a name. Add anonymous function syntax to Lox so that this works:
>
> ```
> fun thrice(fn) {
>   for (var i = 1; i <= 3; i = i + 1) {
>     fn(i);
>   }
> }
>
> thrice(fun (a) {
>   print a;
> });
> // "1".
> // "2".
> // "3".
> ```
>
> How do you handle the tricky case of an anonymous function expression occurring in an expression statement:
>
> ```
> fun scope(a) {
>   var a = "local";
> }
> ```
>
> In other words, are a function’s parameters in the same scope as its local variables, or in an outer scope? What does Lox do? What about other languages you are familiar with? What do you think a language should do?


this seems very doable. if we simply bind it to an "internal" name, i.e. "lambda:<line>:<col>" or something, then we should be good to go.

```
// ex 1: assignment:
var f = fun (name) { print "hello " + name; }

// ex 2: inline pass
thrice(fun (a) {
  print a;
});

// ex 3: inline call
fun (name) { print "hello " + name; }("Mr. Foo")
```

actually, we don't need an internal name. a lambda expr can just evaluate to a LoxFunction! if it's called, it knows how to behave. if it's value is inspected, it'll use .toString() and say lambda#1234 or whatever. so sick! that's exactly what functions are doing, too. this is so similar. we don't bind to the environment because the environment is truly only for named, lexical stuff in our program. kindof relevatory that a LoxFunction instance is the value. crazy. that's what I was hung up on for so long. but it makes total sense.

the parsing is not so bad. I now realize that the lambda expr and function stmt will live in totally separate spots. expr and stmt are totally distinct in our grammar, after all. that's fine, we add a new production in primary. it could go anywhere though i think, since the fun keyword makes it unambiguous.

last, what about the case of an expr stmt lambda? E.g.
```
fun () {};
```

we just need to let parsing of function decl fall through when it doesn't detect the name. this is easy with an extra lookahead. no other statements will be matched, so we'll end up in an expression statement, and then the expression will parsed, and voila.

# 3.
> Is this program valid?
> ```
> fun scope(a) {
>   var a = "local";
> }
> ```
> In other words, are a function’s parameters in the same scope as its local variables, or in an outer scope? What does Lox do? What about other languages you are familiar with? What do you think a language should do?

My intuition tells me that's wrong, that params should be in the same scope as the local variables. That's what Lox does, too - on function call, it creates a new environment for the function to run in and defines the parameters inside that env.

For languages without a syntactical distinction between var declaration and assignment, i.e. python:
```
def scope(a):
  a = "local"
```
you cannot tell if you are shadowing or using the same variable. this is valid python, and I assume under the hood it's the same variable.
